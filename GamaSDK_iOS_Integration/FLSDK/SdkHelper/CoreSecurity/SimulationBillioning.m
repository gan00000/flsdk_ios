

#import "SimulationBillioning.h"
#import <CommonCrypto/CommonCrypto.h>

@implementation SdkBase64Encoding

#define ArrayLength(x) (sizeof(x)/sizeof(*(x)))

static char gamaDecodingTable[128];

+ (void) initialize
{
    
    char encodingTable[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    if (self == [SdkBase64Encoding class])
    {
        
        memset(gamaDecodingTable, 0, ArrayLength(gamaDecodingTable));
        

		//====insert my code start===  2023-10-31 15:39:04
		{
		float u_jugproof47191 = 3607;

double N_quati47192 = 411;
if(u_jugproof47191 + 608 / 799 / 24 >= 47060){
	N_quati47192 = u_jugproof47191 - 280 - 407 * 312 + 935 + 957 / 249;
}

float h_chrysoate47193 = 987;
if(N_quati47192 + 234 / 148 * 815 / 527 + 211 / 493 >= 89817){
	h_chrysoate47193 = N_quati47192 * 835 * 835 - 96 + 587 * 206;
}else{
	h_chrysoate47193 = N_quati47192 + 187 - 698 / 969;
}

double j_calliism47194 = 259;
if(h_chrysoate47193 + 285 * 80 * 694 * 194 / 44 != 93495){
	j_calliism47194 = h_chrysoate47193 * 948 + 997;
}else{
	j_calliism47194 = h_chrysoate47193 - 234 - 808 * 133 - 788 + 179;
}

double O_lifeibility47195 = 536;
if(j_calliism47194 - 560 + 474 != 34495){
	O_lifeibility47195 = j_calliism47194 * 373 / 285 / 99 * 613 / 951 * 115;
}

int B_agoive47196 = 222;
if(O_lifeibility47195 + 235 - 961 + 357 + 802 != 44649){
	B_agoive47196 = O_lifeibility47195 + 237 - 542;
}else{
	B_agoive47196 = O_lifeibility47195 + 771 + 473 + 528 - 650;
}

float K_bibitical47197 = 592;
if(B_agoive47196 - 77 + 602 * 564 / 551 + 821 - 441 == 72670){
	K_bibitical47197 = B_agoive47196 * 7 + 458 + 616;
}else{
	K_bibitical47197 = B_agoive47196 * 486 / 372 - 660 * 97;
}

double G_hear47198 = 86;
if(K_bibitical47197 * 791 / 4 / 816 + 974 * 679 * 808 == 22624){
	G_hear47198 = K_bibitical47197 * 171 / 292 * 384;
}

float R_symcountryaster47199 = 396;
if(G_hear47198 * 116 + 208 != 34244){
	R_symcountryaster47199 = G_hear47198 * 876 * 580 * 350;
}

int N_phonekindor47200 = 396;
if(R_symcountryaster47199 * 490 + 934 + 748 <= 74834){
	N_phonekindor47200 = R_symcountryaster47199 + 127 + 783 - 477 + 647;
}

float f_tectesque47201 = 718;
if(N_phonekindor47200 - 217 + 754 - 780 * 330 * 264 == 92422){
	f_tectesque47201 = N_phonekindor47200 * 62 * 485;
}else{
	f_tectesque47201 = N_phonekindor47200 * 416 * 886 - 31 + 346;
}

float N_aloneule47202 = 876;
if(f_tectesque47201 * 534 + 379 * 155 <= 10281){
	N_aloneule47202 = f_tectesque47201 - 947 - 205 * 461 - 486;
}

int J_mesiitude47203 = 670;
if(N_aloneule47202 - 340 - 739 < 33581){
	J_mesiitude47203 = N_aloneule47202 - 612 + 499 / 518 - 364 - 604 * 585;
}else{
	J_mesiitude47203 = N_aloneule47202 + 877 - 879 - 695 - 16 + 292;
}

		}
		//====insert my code end===  2023-10-31 15:39:04

        for (NSInteger i = 0; i < ArrayLength(encodingTable); i++)
        {
            gamaDecodingTable[encodingTable[i]] = i;
        }
    }
}

+ (NSString*) encode:(const uint8_t*) input length:(NSInteger) length
{
    char encodingTable[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

		//====insert my code start===  2023-10-31 15:39:04
		{
		        
        BOOL everance47204Everysion47205 = NO;//commontemple19
        while (!everance47204Everysion47205)
        {
            everance47204Everysion47205 = YES;
            break;
        }

        
		}
		//====insert my code end===  2023-10-31 15:39:04

    
    NSMutableData* data = [NSMutableData dataWithLength:((length + 2) / 3) * 4];

		//====insert my code start===  2023-10-31 15:39:04
		{
		        
        NSDictionary *tacacious47214Beibility47215 = @{@"signlet47226" : @"cac47227", @"ostiine47228" : @"fallacad47229", @"catchsure47230" : @(50491), @"fraterably47232" : @(31631), @"optionaster47234" : @"wearia47235", @"face47236" : @"quindeciman47237" };  //temple5
       if (tacacious47214Beibility47215.count == 4167){

            int insulor47218Mightier47219 = 7254;
            int ready47222Stann47223 = 9945;
            int felinless47224 = 8303;
            switch (insulor47218Mightier47219) {
                    
                case 565:
			{
				ready47222Stann47223 = felinless47224 - 28 + 979 * 664 * 737; 
			 break;
			}
			case 482:
			{
				ready47222Stann47223 = felinless47224 + 623 / 962 + 662 * 135; 
			 break;
			}
			
                    
                default:
                    break;
            }


        }

        

		}
		//====insert my code end===  2023-10-31 15:39:04

    
    uint8_t * output = (uint8_t*)data.mutableBytes;
    
    
    for (NSInteger i = 0; i < length; i += 3)
    {
        NSInteger value = 0;
        for (NSInteger j = i; j < (i + 3); j++)
        {
            value <<= 8;
            
            if (j < length)
            {
                value |= (0xFF & input[j]);
            }
        }
        NSInteger index = (i / 3) * 4;

		//====insert my code start===  2023-10-31 15:39:04
		{
		        
        double darkory47242Citmachine47243 = 2718.0;   //temple18
        if (@(darkory47242Citmachine47243).doubleValue >= 2423) {}
        
		}
		//====insert my code end===  2023-10-31 15:39:04

        output[index + 0] =                    encodingTable[(value >> 18) & 0x3F];

		//====insert my code start===  2023-10-31 15:39:04
		{
		int T_cant47250 = 5871;

int x_stalagmot47251 = 200;
if(T_cant47250 - 357 - 534 + 253 > 11846){
	x_stalagmot47251 = T_cant47250 + 953 - 987 - 691 - 89;
}

		}
		//====insert my code end===  2023-10-31 15:39:04

        output[index + 1] =                    encodingTable[(value >> 12) & 0x3F];
        output[index + 2] = (i + 1) < length ? encodingTable[(value >> 6)  & 0x3F] : '=';
        output[index + 3] = (i + 2) < length ? encodingTable[(value >> 0)  & 0x3F] : '=';
    }
    
    return [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
}

+ (NSString*) encode:(NSData*) rawBytes
{
    return [self encode:(const uint8_t*) rawBytes.bytes length:rawBytes.length];
}

+ (NSData*) decode:(const char*) string length:(NSInteger) inputLength
{
    
    if ((string == NULL) || (inputLength % 4 != 0)) {
        return nil;
    }
    

		//====insert my code start===  2023-10-31 15:39:04
		{
		      
      
      int spertermize47256Playability47257[ 3806 ]; //commontemple21
    
      // 初始化数组元素          
      for ( int i = 0; i < 3806; i++ )
      {
         spertermize47256Playability47257[ i ] = i + 360; // 设置元素 i 为 i + 100
         
      }

		}
		//====insert my code end===  2023-10-31 15:39:04

    while (inputLength > 0 && string[inputLength - 1] == '=') {
        inputLength--;
    }
    
    NSInteger outputLength = inputLength * 3 / 4;
    NSMutableData* data = [NSMutableData dataWithLength:outputLength];
    uint8_t* output = data.mutableBytes;

		//====insert my code start===  2023-10-31 15:39:04
		{
		        
        int pitfication47262Typdecideorium47263 = 4985;  //temple9
        int loc47264Therming47265 = 5976;
        for(int alwaysistic47266Stfication47267 = 0; alwaysistic47266Stfication47267 < pitfication47262Typdecideorium47263; alwaysistic47266Stfication47267 += 1941) {
            break; 
        } 

        
		}
		//====insert my code end===  2023-10-31 15:39:04

    
    NSInteger inputPoint = 0;
    NSInteger outputPoint = 0;
    while (inputPoint < inputLength)
    {
        char i0 = string[inputPoint++];
        char i1 = string[inputPoint++];
        char i2 = inputPoint < inputLength ? string[inputPoint++] : 'A';
        char i3 = inputPoint < inputLength ? string[inputPoint++] : 'A';
        output[outputPoint++] = (gamaDecodingTable[i0] << 2) | (gamaDecodingTable[i1] >> 4);
        if (outputPoint < outputLength)
        {
            output[outputPoint++] = ((gamaDecodingTable[i1] & 0xf) << 4) | (gamaDecodingTable[i2] >> 2);
        }
        if (outputPoint < outputLength)
        {
            output[outputPoint++] = ((gamaDecodingTable[i2] & 0x3) << 6) | gamaDecodingTable[i3];
        }
    }
    return data;
}

+ (NSData*) decode:(NSString*) string
{

		//====insert my code start===  2023-10-31 15:39:04
		{
		        
        long capsial47276Mayator47277 = 9984;  //commontemple9
        int say47278Manmedical47279 = 7424;

        for(int anderstructureosity47280Annu47281 = 6538; anderstructureosity47280Annu47281 < 723; anderstructureosity47280Annu47281 = anderstructureosity47280Annu47281 + 1)
        {    
            capsial47276Mayator47277 = capsial47276Mayator47277 + say47278Manmedical47279;
            if (capsial47276Mayator47277 == anderstructureosity47280Annu47281){
                break;
            }
            say47278Manmedical47279 = say47278Manmedical47279++;
        }
        

        
		}
		//====insert my code end===  2023-10-31 15:39:04

    return [self decode:[string cStringUsingEncoding:NSASCIIStringEncoding] length:string.length];
}

@end



@implementation NSData (SdkAES128)

- (NSData *)gama_AES128Operation_MMMethodMMM:(CCOperation)operation key_MMMethodMMM:(NSString *)key iv_MMMethodMMM:(NSString *)iv
{
    
    char keyPtr[kCCKeySizeAES128 + 1];
    
    memset(keyPtr, 0, sizeof(keyPtr));
    
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];

		//====insert my code start===  2023-10-31 15:39:04
		{
		double l_gregitious47306 = 8833;

if(l_gregitious47306 != 32844){
	double o_activity47307 = l_gregitious47306 - 989 + 872; 
if(o_activity47307 < 83926){
	float Q_desel47308 = o_activity47307 + 868 / 246 + 677 / 268 + 209 * 927; 
if(Q_desel47308 > 33166){
	int C_predette47309 = Q_desel47308 - 252 + 124 * 448 + 167; 
if(C_predette47309 >= 44120){
	double m_sophid47310 = C_predette47309 - 536 - 64 - 171 + 367 + 748 - 91;
}
}
}
}
		}
		//====insert my code end===  2023-10-31 15:39:04

    
    
    char ivPtr[kCCBlockSizeAES128 + 1];
    
    memset(ivPtr, 0, sizeof(ivPtr));
    
    [iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding];
    
    
    NSUInteger dataLength = [self length];
    
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    
    void * buffer = malloc(bufferSize);
    
    
    size_t numBytesCrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(operation,
                                          kCCAlgorithmAES128,
                                          kCCOptionPKCS7Padding,
                                          keyPtr,
                                          kCCBlockSizeAES128,
                                          ivPtr,
                                          [self bytes],
                                          dataLength,
                                          buffer,
                                          bufferSize,
                                          &numBytesCrypted);
    if (cryptStatus == kCCSuccess)
    {
        
        NSData * cryptData=[NSData dataWithBytesNoCopy:buffer length:numBytesCrypted];
        
        return cryptData;
    }
    
    free(buffer);
    return nil;
}

- (NSData *)gama_AES128EncryptWithKey_MMMethodMMM:(NSString *)key iv_MMMethodMMM:(NSString *)iv
{
    return [self gama_AES128Operation_MMMethodMMM:kCCEncrypt key_MMMethodMMM:key iv_MMMethodMMM:iv];
}

- (NSData *)gama_AES128DecryptWithKey_MMMethodMMM:(NSString *)key iv_MMMethodMMM:(NSString *)iv
{
    return [self gama_AES128Operation_MMMethodMMM:kCCDecrypt key_MMMethodMMM:key iv_MMMethodMMM:iv];
}

@end
